"""
Plotting functions for Bicorr project
Moving them here to keep the bicorr.py file cleaner
PFS, March 2018
  
Changelog:
2018_03_15: Move a few functions here
"""

import os
import os.path
import time
import numpy as np
np.set_printoptions(threshold=np.nan) # print entire matrices
import pandas as pd
import scipy.io as sio
import sys
import matplotlib
import seaborn as sns
sns.set(style='ticks')

#matplotlib.use('agg') # for flux
import matplotlib.pyplot as plt
import time
from tqdm import *

from bicorr import *


def test_function():
    pass


############### SOME GENERAL FUNCTIONS TO KEEP AROUND ########################
def save_fig_to_folder(fig_filename,fig_folder='fig',extensions=['png']):
    """
    Summary: Save .png of current matplotlib plot to fig_folder / fig_filename
    Code will check to make sure fig_folder exists. If not, create folder then save .png to folder
    
    Parameters
    ----------
    fig_filename : str
        Filename to use for saving the figure
    fig_folder : str, optional
        Folder where to save the image, relative to cwd
    extensions: str, optional
        File save format. If several, produce all.

    Returns
    -------
    n/a
    """
    # Don't cut off labels
    plt.tight_layout()
    # If saving to same folder
    if fig_folder is None:
        plt.savefig(fig_filename)
    # If saving to a subfolder
    else:
        try:
            os.stat(fig_folder)
        except:
            os.mkdir(fig_folder)
        for extension in extensions:
            plt.savefig(fig_folder+'/'+fig_filename+'.'+extension) 

def step_plot(edges,y, linewidth=.5, color='k'):
    """
    Plot a step plot. Meant for use with histogram data generated by:
        counts, bin_edges = np.histogram(x_samples,bin_edges)
        bicorr.step_plot(bin_edges,counts)
    
    Parameters
    ----------
    edges : ndarray
        Bin edges
    y : ndarray
        Bin counts
    linewidth : float, optional
        Width of step lines
    color : float, optional
        Color of lines

    Returns
    -------
    n/a
    """
    # Horizontal lines
    for i in range(len(y)):
        plt.hlines(y[i],edges[i],edges[i+1],linewidth=linewidth,color=color)
    # Vertical lines
    for i in range(len(y)-1):
        plt.vlines(edges[i+1],y[i],y[i+1],linewidth=linewidth,color=color)

            
##################### EXPERIMENTAL SETUP STUFF ###########################
def plot_det_df(det_df, which = ['index','angle'], save_flag = False, fig_folder = 'fig', show_flag = True):
    """ 
    Make some plots to visualize the data in det_df, which can be loaded using `load_det_df`.
    
    Parameters
    ----------
    det_df : pandas dataFrame
        dataFrame of detector pair indices and angles
    which : list of str, optional
        Which plots to show? Options include 'index', 'angle'
    save_flag : bool, optional
        save plots to file
    fig_folder : str, optional
        where to save plots
    show_flag : bool, optional
        display plots
        
    Returns
    -------
    n/a    
    """
    if 'index' in which:
        # Detector pair indices
        plt.scatter(det_df['d1'],det_df['d2'],s=13,marker='s',edgecolor='none',c=det_df.index.values,cmap='viridis')
        plt.grid(True, which='both')
        plt.xlim([0,48]); plt.ylim([0,48])
        plt.xlabel('Detector 1 channel'); plt.ylabel('Detector 2 channel')
        cbar = plt.colorbar()
        cbar.set_label('Detector pair index value')
        plt.title('Detector pair indices')
        plt.axes().set_aspect('equal')
        if save_flag: save_fig_to_folder('det_df_ch_to_index',fig_folder=fig_folder) 
        if show_flag: plt.show()
        plt.clf()
    
    if 'angle' in which:
        # Detector pair angles
        plt.scatter(det_df['d1'],det_df['d2'],c=det_df['angle'],s=18,marker='s',edgecolor='none',cmap='viridis')
        cbar = plt.colorbar()
        cbar.set_label('Angle (degrees)')
        plt.xlim([0,48]); plt.ylim([0,48])
        plt.xlabel('Detector 1 channel'); plt.ylabel('Detector 2 channel')
        plt.title('Angle between all detector pairs (degrees)')
        plt.axes().set_aspect('equal')
        if save_flag: save_fig_to_folder('det_df_ch_to_angle',fig_folder=fig_folder) 
        if show_flag: plt.show()
        plt.clf()
            
            
################# SINGLES_HIST ########################
def plot_singles_hist(singles_hist,dt_bin_edges,
                      save_flag = False, fig_folder ='fig',
                      show_flag = False):
    """
    Plot singles TOF distribution from singles_hist for all channels.    
    Future development option: incorporate a channel rather than summing across all.
    
    Parameters
    ----------
    singles_hist : ndarray
        Histogram of singles timing information
        Dimension 0: particle type, 0=n, 1=g
        Dimension 1: detector channel
        Dimension 2: dt bin
    dt_bin_edges : ndarray
        Time bin edges array
    save_flag : bool, optional
        save plots to file
    fig_folder : str, optional
        where to save plots
    show_flag : bool, optional
        display plots
        
    Returns
    -------
    n/a
    """
    plt.figure(figsize=(4,3))
    dt_bin_centers = (dt_bin_edges[:-1]+dt_bin_edges[1:])/2
    plt.plot(dt_bin_centers,np.sum(singles_hist[0,:,:],axis=(0)))
    plt.plot(dt_bin_centers,np.sum(singles_hist[1,:,:],axis=(0)))
    plt.xlabel('Time (ns)')
    plt.ylabel('Number of events')
    plt.title('Singles TOF distribution, all channels')
    plt.legend(['N','G'])
    plt.yscale('log')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('singles_TOF_dist.png',fig_folder)
    if show_flag: plt.show()
    plt.clf()


def Sd_vs_angle_all(singles_df, show_flag = True, save_flag = True, 
                    fig_folder = 'fig', normalized = False):
    """
    Generate plots of counts vs. angle for all pairs separately
    
    Parameters
    ----------
    singles_df : pandas dataFrame
        singles dataframe with counts already entered
    
    Returns
    -------
    n/a
    """            
    plt.figure(figsize=(4,3))
    plt.errorbar(singles_df['ch'],singles_df['Sd'],yerr=singles_df['Sd_err'],
                 fmt='.',markersize=5,elinewidth=.5)
    plt.xlabel('detector channel')
    plt.ylabel('Sd (counts)')
    plt.title('br-subtracted $n$ sum')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('Sd_vs_angle_raw',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    plt.clf()
            
            
################## BHP ##########################
def bhp_plot(bicorr_hist_plot, dt_bin_edges, title = None,
                vmin = None, vmax = None,
                save_flag = False, save_filename = 'bicorr', 
                save_folder = 'fig', extensions = ['png'],
                show_flag = False, clear = True):
    """
    Creates 2d bicorr hist plot
    
    Parameters
    ----------
    bicorr_hist_plot : ndarray
        Array to plot. Two-dimensional with axes sizes corresponding to dt_bin_edges x dt_bin_edges.
    dt_bin_edges : ndarray
        One-dimensional array of time bin edges
    title : str, optional
    vmin : float, optional
        Minimum of colorbar range
    vmax : float, optional
        Maximum of colorbar range
    save_flag : bool, optional
        Do you want to save to disk using function save_fig_to_folder
    save_filename : str, optional
        Filename for bicorrelation image (.png will be added)
    save_folder : str, optional
        Destination folder location for storing bicorrelation image
    extensions: str, optional
        File save format. If several, produce all.
    show_flag : bool, optional   
        Display plot to current session with plt.show()
    clear : bool, optional
        Clear matplotlib after creating bicorr plot. (If set to False, you can add more plots before showing, saving, or clearing the figure)
    
    Returns
    -------
    none
    """
    plt.figure(figsize=[4,4])
    plt.pcolormesh(dt_bin_edges, dt_bin_edges, bicorr_hist_plot.T, norm=matplotlib.colors.LogNorm(), vmin = vmin, vmax = vmax, cmap="jet")
    cbar = plt.colorbar(fraction = 0.043, pad=0.1)
    if np.max(bicorr_hist_plot) >=1: # absolute counts
        cbar.set_label('counts')
    else: # normalized
        cbar.set_label('counts / (fission$\cdot$ns$^2$$\cdot$pair)')
    plt.xlabel('$\Delta t_1$ (ns)')
    plt.ylabel('$\Delta t_2$ (ns)')
    if title is not None: plt.title(title)
    plt.axes().set_aspect('equal')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder(save_filename, save_folder, extensions)
    if show_flag: plt.show()
    if clear: plt.clf()
            
            
            
            
            
############# COUNTS VS. ANGLE #################################
def counts_vs_angle_all(det_df, show_flag = True, save_flag = True, 
                    fig_folder = 'fig', normalized = False):
    """
    Generate plots of counts vs. angle for all pairs separately
    
    Parameters
    ----------
    det_df : pandas dataFrame
        detector pair dataframe with counts already entered
    normalized : bool, optional
        option to plot normalized columns
    
    Returns
    -------
    n/a
    """
    # Positive counts vs. angle
    plt.figure(figsize=(4,3))
    plt.errorbar(det_df['angle'],det_df['Cp'],yerr=det_df['Cp']**.5,
                 fmt='.',markersize=5,elinewidth=.5)
    plt.xlabel('Angle (degrees)')
    plt.ylabel('Cp (counts)')
    plt.title('positive $nn$ sum')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('Cp_vs_angle_raw',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    plt.clf()    
    
    # Negative counts vs. angle
    plt.figure(figsize=(4,3))
    plt.errorbar(det_df['angle'],det_df['Cn'],yerr=det_df['Cn']**.5,
                 fmt='.',markersize=5,elinewidth=.5)
    plt.xlabel('Angle (degrees)')
    plt.ylabel('Cn (counts)')
    plt.title('negative $nn$ sum')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('Cn_vs_angle_raw',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    plt.clf()   
    
    # Negative counts vs. angle
    plt.figure(figsize=(4,3))
    plt.errorbar(det_df['angle'],det_df['Cd'],yerr=det_df['Cd_err'],
                 fmt='.',markersize=5,elinewidth=.5)
    plt.xlabel('Angle (degrees)')
    plt.ylabel('Cd (counts)')
    plt.title('br-subtracted $nn$ sum')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('Cd_vs_angle_raw',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    plt.clf()   
    
    if normalized:
        print('yes')
        # Negative counts vs. angle
        plt.figure(figsize=(4,3))
        plt.errorbar(det_df['angle'],det_df['Nd'],yerr=det_df['Nd_err'],
                     fmt='.',markersize=5,elinewidth=.5)
        plt.xlabel('Angle (degrees)')
        plt.ylabel('Nd (counts/fission)')
        plt.title('normalized br-subtracted $nn$ sum')
        sns.despine(right=False)
        if save_flag: save_fig_to_folder('Nd_vs_angle_raw',fig_folder,extensions=['png','pdf'])
        if show_flag: plt.show()
        plt.clf()  
        
        
        
######################### SLICES ############################
def plot_bhp_slice(bhp_slice, dt_bin_edges, normalized = None,
                   title = None, show_flag = False,
                   save_flag = False, save_filename = 'bhp_slice', save_folder = 'fig', new_fig = True, clear = True, msize=5,
                   t_norm_range = None):
    """
    Plot bhp slice.
    
    Parameters
    ----------
    bhp_slice : ndarray
        Slice through bhp at delta_tj_min, produce with slice_bhp()
    dt_bin_edges : ndarray
        One-dimensional array of time bin edges
    normalized : str
        None: Don't normalize
        'int': Normalize by integral
        'max': Normalize by height
    title : str
        Title for plot. Ex: '$\Delta t_j$ = {}'.format(dt_bin_centers[i])
    show_flag : bool
        Option to show figure
    save_flag : bool
        Option to save figure to file
    save_filename : str
        filename where to save figure
    save_folder : str
        foldername where to save figure  
    new_fig : bool, optional
        option to open new fig (if False, plots on existing axes)
    clear : bool, optional
        Clear matplotlib after creating bicorr plot. (If set to False, you can add more plots before showing, saving, or clearing the figure)   
    msize : int, optional
        Marker size
    t_norm_range : list of floats, optional
        Range of times for normalization. Ex [15,150]
    
    Returns
    -------
    n/a
    
    
    NEED TO UPDATE
    How I use the mask....
    """
       
    if new_fig: plt.figure(figsize=(4,4))
    
    if t_norm_range is not None:
        imin = np.digitize(t_norm_range[0],dt_bin_edges)-1
        imax = np.digitize(t_norm_range[1],dt_bin_edges)-1  
    else:
        imin = 0
        imax = len(dt_bin_edges)
    
    if normalized is 'max':   
        plt.plot(centers(dt_bin_edges),bhp_slice/np.max(bhp_slice[imin:imax]),'.-',markersize=msize,linewidth = 1)
        plt.ylabel('Counts normalized by maximum')
    elif normalized is 'int': 
        plt.plot(centers(dt_bin_edges),bhp_slice/np.sum(bhp_slice[imin:imax]),'.-',markersize=msize,linewidth = 1)
        plt.ylabel('Counts normalized by integral')
    else: 
        plt.plot(centers(dt_bin_edges),bhp_slice,'.-',markersize=msize,linewidth = 1)
        plt.ylabel('Counts')
    plt.xlabel('$\Delta t_i$')
    
    if title is not None: plt.title(title)
    sns.despine(right=False)
    # plt.axes().set_aspect('equal')
    if save_flag: save_fig_to_folder(save_filename, save_folder, extensions)
    if show_flag: plt.show()
    if clear: plt.clf()


    