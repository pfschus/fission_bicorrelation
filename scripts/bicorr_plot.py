"""
Plotting functions for Bicorr project
Moving them here to keep the bicorr.py file cleaner
PFS, March 2018
  
Changelog:
2018_03_15: Move a few functions here
"""

import os
import os.path
import time
import numpy as np
np.set_printoptions(threshold=np.nan) # print entire matrices
import pandas as pd
import scipy.io as sio
import sys
import matplotlib
from matplotlib.pyplot import cm 
import seaborn as sns
sns.set(style='ticks')

from matplotlib import rcParams

#matplotlib.use('agg') # for flux
import matplotlib.pyplot as plt
import time
from tqdm import *

# Don't import any bicorr modules here
# Other modules will import bicorr_plot, but not the other way around


############### SOME GENERAL FUNCTIONS TO KEEP AROUND ########################
def save_fig_to_folder(fig_filename,fig_folder='fig',extensions=['png','pdf']):
    """
    Summary: Save .png of current matplotlib plot to fig_folder / fig_filename
    Code will check to make sure fig_folder exists. If not, create folder then save .png to folder
    
    Parameters
    ----------
    fig_filename : str
        Filename to use for saving the figure
    fig_folder : str, optional
        Folder where to save the image, relative to cwd
    extensions: str, optional
        File save format. If several, produce all.

    Returns
    -------
    n/a
    """
    # Don't cut off labels
    plt.tight_layout()
    # If saving to same folder
    if fig_folder is None:
        plt.savefig(fig_filename)
    # If saving to a subfolder
    else:
        try:
            os.stat(fig_folder)
        except:
            os.mkdir(fig_folder)
        for extension in extensions:
            plt.savefig(fig_folder+'/'+fig_filename+'.'+extension,dpi=300) 
            
def histogram_metrics(values, xlabel = 'x', ylabel = 'y'):
    """
    Plot histogram with some metrics overlaid (mean, std, median)
    
    Parameters
    ----------
    values : array-like
        Values for the histogram
    xlabel : str, optional
    ylabel : str, optional
    """
    mu = np.mean(values)
    sigma = np.std(values)
    med = np.median(values)
    
    plt.figure(figsize=(4,3))
    sns.distplot(values, rug=True)
    plt.axvline(mu,color='k',linewidth=1)
    plt.axvline(mu-sigma,color='k',linewidth=.5)
    plt.axvline(mu+sigma,color='k',linewidth=.5)
    plt.axvline(med,color='r',linewidth=.5)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    sns.despine(right=False)
    plt.show()

def step_plot(edges,y, linewidth=.5, color='k', zorder = 1):
    """
    Plot a step plot. Meant for use with histogram data generated by:
        counts, bin_edges = np.histogram(x_samples,bin_edges)
        bicorr.step_plot(bin_edges,counts)
    
    Parameters
    ----------
    edges : ndarray
        Bin edges
    y : ndarray
        Bin counts
    linewidth : float, optional
        Width of step lines
    color : float, optional
        Color of lines
    zorder : int, optional
        Order of layer. Lower integer = farther back

    Returns
    -------
    n/a
    """
    # Horizontal lines
    for i in range(len(y)):
        plt.hlines(y[i],edges[i],edges[i+1],linewidth=linewidth,color=color,zorder=zorder)
    # Vertical lines
    for i in range(len(y)-1):
        plt.vlines(edges[i+1],y[i],y[i+1],linewidth=linewidth,color=color,zorder=zorder)

        
            
##################### EXPERIMENTAL SETUP STUFF ###########################
def plot_det_df(det_df, which = ['index','angle'], cmap='viridis', title_flag = True, save_flag = False, fig_folder = 'fig', show_flag = True, clear_flag = True):
    """ 
    Make some plots to visualize the data in det_df, which can be loaded using `load_det_df`.
    
    Parameters
    ----------
    det_df : pandas dataFrame
        dataFrame of detector pair indices and angles
    which : list of str, optional
        Which plots to show? Options include 'index', 'angle'
    cmap : str, optional
        Colormap
    title_flag : bool, optional
    save_flag : bool, optional
        save plots to file
    fig_folder : str, optional
        where to save plots
    show_flag : bool, optional
        display plots
    clear_flag : bool, optional
        whether to clear matplotlib figure
        
    Returns
    -------
    n/a    
    """
    if 'index' in which:
        # Detector pair indices
        plt.figure(figsize=(4,4))
        plt.scatter(det_df['d1'],det_df['d2'],s=13,marker='s',edgecolor='none',c=det_df.index.values,cmap=cmap)
        plt.grid(True, which='both')
        plt.xlim([0,48]); plt.ylim([0,48])
        plt.xlabel('Detector 1 channel'); plt.ylabel('Detector 2 channel')
        cbar = plt.colorbar(fraction = 0.043, pad=0.1)
        cbar.set_label('Detector pair index value')
        if title_flag: plt.title('Detector pair indices\n')
        plt.axes().set_aspect('equal')
        if save_flag: save_fig_to_folder('det_df_ch_to_index',fig_folder=fig_folder) 
        if show_flag: plt.show()
        if clear_flag: plt.clf()
    
    if 'angle' in which:
        # Detector pair angles
        plt.figure(figsize=(4,4))
        plt.scatter(det_df['d1'],det_df['d2'],c=det_df['angle'],s=18,marker='s',edgecolor='none',cmap=cmap)
        plt.xlim([0,48]); plt.ylim([0,48])
        plt.xlabel('Detector 1 channel'); plt.ylabel('Detector 2 channel')
        cbar = plt.colorbar(fraction = 0.043, pad=0.1)
        cbar.set_label('Angle (degrees)')
        if title_flag: plt.title('Angle between all detector pairs (degrees)\n')
        plt.axes().set_aspect('equal')
        if save_flag: save_fig_to_folder('det_df_ch_to_angle',fig_folder=fig_folder) 
        if show_flag: plt.show()
        if clear_flag: plt.clf()

##################### GENERATING BICORR FILE ###########################

def bicorr_checkpoint_plots(bicorr_data, fig_folder = 'fig', show_flag = False):
    """
    Construct and store checkpoint plots from the bicorr_data matrix.
    
    Require: bicorr_data
    Modify: fig_folder, show_flag
            if fig_folder = None, save to same folder
            if fig_folder = an int, that is the folder number and fig_folder is set to `#/bicorr_fig`
    Effect: Stores .png images for plots to fig_folder
    """
    # Make a subfolder to store the checkpoint plots
    if isinstance(fig_folder,str) == False:
        fig_folder = str(fig_folder)+'/bicorr_fig'
    
    # If the folder doesn't exist yet, create it
    try:
        os.stat(fig_folder)
    except:
        os.mkdir(fig_folder)        
        
    # Which detector pairs fired?
    plt.plot(bicorr_data['det1ch'],bicorr_data['det2ch'],'.k')
    plt.xlabel('Detector 1 channel')
    plt.ylabel('Detector 2 channel')
    plt.title('Detector pairs with bicorrelation events')
    save_fig_to_folder('bicorr_pairs_scatter.png',fig_folder)
    if show_flag: plt.show()
    plt.clf()
    
    # Plot count rate for each detector pair
    plt.figure(figsize=(7,6))
    plt.hist2d(bicorr_data['det1ch'],bicorr_data['det2ch'],bins=np.arange(-0.5,46.5,1),cmin=1,cmap='viridis')
    plt.ylim([-.5,46.5])
    plt.colorbar()
    plt.grid(True, which='both')
    plt.xticks([i for i in np.arange(0,46,4)])
    plt.yticks([i for i in np.arange(0,46,4)])
    plt.xlabel('Detector 1 channel')
    plt.ylabel('Detector 2 channel')
    plt.title('Frequency of detector pair interactions')
    save_fig_to_folder('bicorr_pairs_2dhist.png',fig_folder)
    if show_flag: plt.show()
    plt.clf()

    # Plot event number vs. line in
    plt.plot(bicorr_data['event'])
    plt.xlabel('Line number')
    plt.ylabel('Event number')
    plt.title('Event number vs. line number')
    save_fig_to_folder('bicorr_all_evnum.png',fig_folder)
    if show_flag: plt.show()
    plt.clf()




        
            
################# SINGLES_HIST ########################
def plot_singles_hist(singles_hist,dt_bin_edges,
                      save_flag = False, fig_folder ='fig',
                      show_flag = False):
    """
    Plot singles TOF distribution from singles_hist for all channels.    
    Future development option: incorporate a channel rather than summing across all.
    
    Parameters
    ----------
    singles_hist : ndarray
        Histogram of singles timing information
        Dimension 0: particle type, 0=n, 1=g
        Dimension 1: detector channel
        Dimension 2: dt bin
    dt_bin_edges : ndarray
        Time bin edges array
    save_flag : bool, optional
        save plots to file
    fig_folder : str, optional
        where to save plots
    show_flag : bool, optional
        display plots
        
    Returns
    -------
    n/a
    """
    plt.figure(figsize=(4,3))
    dt_bin_centers = (dt_bin_edges[:-1]+dt_bin_edges[1:])/2
    plt.plot(dt_bin_centers,np.sum(singles_hist[0,:,:],axis=(0)))
    plt.plot(dt_bin_centers,np.sum(singles_hist[1,:,:],axis=(0)))
    plt.xlabel('Time (ns)')
    plt.ylabel('Number of events')
    plt.title('Singles TOF distribution, all channels')
    plt.legend(['N','G'])
    plt.yscale('log')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('singles_TOF_dist.png',fig_folder)
    if show_flag: plt.show()
    plt.clf()


def Sd_vs_angle_all(singles_df, show_flag = True, save_flag = True, 
                    fig_folder = 'fig', normalized = False):
    """
    Generate plots of counts vs. angle for all pairs separately
    
    Parameters
    ----------
    singles_df : pandas dataFrame
        singles dataframe with counts already entered
    
    Returns
    -------
    n/a
    """            
    plt.figure(figsize=(4,3));
    plt.errorbar(singles_df['ch'],singles_df['Sd'],yerr=singles_df['Sd_err'],
                 fmt='.',markersize=5,elinewidth=.5)
    plt.xlabel('detector channel')
    plt.ylabel('Sd (counts)')
    plt.title('br-subtracted $n$ sum')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('Sd_vs_angle_raw',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    plt.clf()
    
    
            
            
################## BHP ##########################
def bhp_plot(bicorr_hist_plot, dt_bin_edges, title = None,
                vmin = None, vmax = None,
                save_flag = False, save_filename = 'bicorr', 
                save_folder = 'fig', extensions = ['png'],
                show_flag = False, clear = True):
    """
    Creates 2d bicorr hist plot
    
    Parameters
    ----------
    bicorr_hist_plot : ndarray
        Array to plot. Two-dimensional with axes sizes corresponding to dt_bin_edges x dt_bin_edges.
    dt_bin_edges : ndarray
        One-dimensional array of time bin edges
    title : str, optional
    vmin : float, optional
        Minimum of colorbar range
    vmax : float, optional
        Maximum of colorbar range
    save_flag : bool, optional
        Do you want to save to disk using function save_fig_to_folder
    save_filename : str, optional
        Filename for bicorrelation image (.png will be added)
    save_folder : str, optional
        Destination folder location for storing bicorrelation image
    extensions: str, optional
        File save format. If several, produce all.
    show_flag : bool, optional   
        Display plot to current session with plt.show()
    clear : bool, optional
        Clear matplotlib after creating bicorr plot. (If set to False, you can add more plots before showing, saving, or clearing the figure)
    
    Returns
    -------
    none
    """
    plt.figure(figsize=[4,4])
    plt.pcolormesh(dt_bin_edges, dt_bin_edges, bicorr_hist_plot.T, norm=matplotlib.colors.LogNorm(), vmin = vmin, vmax = vmax, cmap="jet")
    cbar = plt.colorbar(fraction = 0.043, pad=0.1)
    if np.max(bicorr_hist_plot) >=1: # absolute counts
        cbar.set_label('counts')
    else: # normalized
        cbar.set_label('counts / (fission$\cdot$ns$^2$$\cdot$pair)')
    plt.xlabel('$\Delta t_1$ (ns)')
    plt.ylabel('$\Delta t_2$ (ns)')
    if title is not None: plt.title(title)
    plt.axes().set_aspect('equal')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder(save_filename, save_folder, extensions)
    if show_flag: plt.show()
    if clear: plt.clf()
            
            
            
            
            
############# COUNTS VS. ANGLE #################################
def counts_vs_angle_all(det_df, show_flag = True, save_flag = True, 
                    fig_folder = 'fig', normalized = False):
    """
    Generate plots of counts vs. angle for all pairs separately
    
    Parameters
    ----------
    det_df : pandas dataFrame
        detector pair dataframe with counts already entered
    normalized : bool, optional
        option to plot normalized columns
    
    Returns
    -------
    n/a
    """
    # Positive counts vs. angle
    plt.figure(figsize=(4,3))
    plt.errorbar(det_df['angle'],det_df['Cp'],yerr=det_df['Cp']**.5,
                 fmt='.',markersize=5,elinewidth=.5,color='k')
    plt.xlabel('Angle (degrees)')
    plt.ylabel('Cp (counts)')
    plt.title('positive $nn$ sum')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('Cp_vs_angle_raw',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    plt.clf()    
    
    # Negative counts vs. angle
    plt.figure(figsize=(4,3))
    plt.errorbar(det_df['angle'],det_df['Cn'],yerr=det_df['Cn']**.5,
                 fmt='.',markersize=5,elinewidth=.5,color='k')
    plt.xlabel('Angle (degrees)')
    plt.ylabel('Cn (counts)')
    plt.title('negative $nn$ sum')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('Cn_vs_angle_raw',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    plt.clf()   
    
    # Negative counts vs. angle
    plt.figure(figsize=(4,3))
    plt.errorbar(det_df['angle'],det_df['Cd'],yerr=det_df['Cd_err'],
                 fmt='.',markersize=5,elinewidth=.5,color='k')
    plt.xlabel('Angle (degrees)')
    plt.ylabel('Cd (counts)')
    plt.title('br-subtracted $nn$ sum')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('Cd_vs_angle_raw',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    plt.clf()   
    
    if normalized:
        print('yes')
        # Negative counts vs. angle
        plt.figure(figsize=(4,3))
        plt.errorbar(det_df['angle'],det_df['Nd'],yerr=det_df['Nd_err'],
                     fmt='.',markersize=5,elinewidth=.5)
        plt.xlabel('Angle (degrees)')
        plt.ylabel('Nd (counts/fission)')
        plt.title('normalized br-subtracted $nn$ sum')
        sns.despine(right=False)
        if save_flag: save_fig_to_folder('Nd_vs_angle_raw',fig_folder,extensions=['png','pdf'])
        if show_flag: plt.show()
        plt.clf()  
        
def W_vs_angle_all(det_df, show_flag = True, save_flag = True, clf_flag = True,
                    fig_folder = 'fig'):
    """
    Generate plots of W vs. angle for all pairs separately
    
    Parameters
    ----------
    det_df : pandas dataFrame
        detector pair dataframe with counts already entered, W calculated
    
    Returns
    -------
    n/a
    """
    # Positive counts vs. angle
    plt.figure(figsize=(4,3))
    plt.errorbar(det_df['angle'],det_df['W'],yerr=det_df['W_err'],
                 fmt='.',markersize=5,elinewidth=.5,zorder=1)
    plt.xlabel('Angle (degrees)')
    plt.ylabel('W (relative doubles counts)')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('W_vs_angle_all',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    if clf_flag: plt.clf()    
    
def W_vs_angle_binned(by_angle_df, show_flag = True, save_flag = True, clf_flag = True,
                      fig_folder = 'fig'):
    """
    Generate plots of W vs. angle for pairs by bin
    
    Parameters
    ----------
    by_angle_df : pandas dataFrame
        Condensed by angle dataframe with W calculated
    
    Returns
    -------
    n/a
    """   
    angle_bin_edges = [by_angle_df.loc[0,'angle_bin_min']]+by_angle_df['angle_bin_max'].values.tolist()
    
    plt.figure(figsize=(4,3))
    plt.errorbar(by_angle_df['angle_bin_centers'],by_angle_df['W'],yerr=by_angle_df['std W'],fmt='.',color='k',zorder=3)
    step_plot(angle_bin_edges,by_angle_df['W'],linewidth=1,zorder=2)
    plt.xlabel('Angle (degrees)')
    plt.ylabel('W (relative doubles counts)')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('W_vs_angle_binned',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()  
    if clf_flag: plt.clf()
    
def W_vs_angle(det_df, by_angle_df, show_flag = True, save_flag = True, clf_flag = True,
                    fig_folder = 'fig'):
    """ 
    Generate plots of W vs. angle for all pairs, overlaid by pairs binned
    """
    angle_bin_edges = [by_angle_df.loc[0,'angle_bin_min']]+by_angle_df['angle_bin_max'].values.tolist()
    
    plt.figure(figsize=(4,3))
    plt.errorbar(det_df['angle'],det_df['W'],yerr=det_df['W_err'],fmt='.',color='r', markersize=5,elinewidth=.5,zorder=1)
    plt.errorbar(by_angle_df['angle_bin_centers'],by_angle_df['W'],yerr=by_angle_df['std W'],fmt='.',color='k',zorder=3)
    step_plot(angle_bin_edges,by_angle_df['W'],linewidth=1,zorder=2)
    plt.xlabel('Angle (degrees)')
    plt.ylabel('W (relative doubles counts)')
    sns.despine(right=False)
    if save_flag: save_fig_to_folder('W_vs_angle_all',fig_folder,extensions=['png','pdf'])
    if show_flag: plt.show()
    if clf_flag: plt.clf()       
    
        
######################### SLICES ############################
def plot_bhp_slice(bhp_slice, bin_edges, bin_units = 'time', 
                   slice_range = None, normalized = None,
                   c = 'k', title = False, show_flag = False,
                   save_flag = False, save_filename = 'bhp_slice', save_folder = 'fig', new_fig = True, clear = True, msize=5,
                   norm_range = None):
    """
    Plot bhp slice.
    
    Parameters
    ----------
    bhp_slice : ndarray
        Slice through bhp at delta_tj_min, produce with slice_bhp()
    bin_edges : ndarray
        One-dimensional array of bin edges
    bin_units : str, optional
        Units for labels. 'time' or 'energy'
    slice_range : array or float, optional
        Range of time or energy values over which slice was taken. Primarily used for creating a title or legend
        if None: not provided
        if array: Min and max of slice range, ex: [slice_dt_min, slice_dt_max]
        if float: Slice position, ex: slice_dt_middle
    normalized : str, optional
        None: Don't normalize
        'int': Normalize by integral
        'max': Normalize by height
    c : str, optional
        Color of step plot
    title : str, optional
        Title for plot. Ex: '$\Delta t_j$ = {}'.format(dt_bin_centers[i])
        if default True, print according to slice_dt_range
        if None, no title printed
        if a str, use custom title
    show_flag : bool
        Option to show figure
    save_flag : bool
        Option to save figure to file
    save_filename : str
        filename where to save figure
    save_folder : str
        foldername where to save figure  
    new_fig : bool, optional
        option to open new fig (if False, plots on existing axes)
    clear : bool, optional
        Clear matplotlib after creating bicorr plot. (If set to False, you can add more plots before showing, saving, or clearing the figure)   
    msize : int, optional
        Marker size
    norm_range : list of floats, optional
        Range of bin edges for normalization. Ex [15,150]
        Not yet available for energy units
    
    Returns
    -------
    n/a
    """
       
    if new_fig: plt.figure(figsize=(4,4))
    
    if norm_range is not None:
        imin = np.digitize(norm_range[0],bin_edges)-1
        imax = np.digitize(norm_range[1],bin_edges)-1  
    else:
        imin = 0
        imax = len(bin_edges)
    
    if normalized is 'max':  
        step_plot(bin_edges, bhp_slice/np.max(bhp_slice[imin:imax]), linewidth=.5, color = c)
        plt.ylabel('Counts normalized by maximum')
    elif normalized is 'int': 
        step_plot(bin_edges, bhp_slice/np.sum(bhp_slice[imin:imax]), linewidth=.5, color = c)
        plt.ylabel('Counts normalized by integral')
    else: 
        step_plot(bin_edges, bhp_slice, linewidth=.5)
        plt.plot(calc_centers(bin_edges),bhp_slice,'.-',markersize=msize,linewidth = .5, color = c)
        plt.ylabel('Counts')
    
    if bin_units is 'time': plt.xlabel('$\Delta t_i$')
    elif bin_units is 'energy': plt.xlabel('$\Delta E_i$')
    
    if title is True: # Make a title according to slice_range
        if type(slice_range) is list: # Min and max boundaries
            plt.title('$\Delta t_j$ = {} to {}'.format(slice_range[0],slice_range[1]))
        else: # float
            plt.title('$\Delta t_j$ = {}'.format(slice_range))
    elif title is False:
        pass
    elif title is not None: # print custom title
        plt.title(title)
    
    sns.despine(right=False)
    # plt.axes().set_aspect('equal')
    if save_flag: save_fig_to_folder(save_filename, save_folder, extensions)
    if show_flag: plt.show()
    if clear: plt.clf()

def plot_bhp_slices(bhp_slices,bin_edges,bin_units='time',slice_range = None,new_fig=True,show_flag=True, log_flag = False):
    '''
    Plot bhp_slices on same axes, normalized by integral
    
    Parameters
    ----------
    bhp_slices : ndarray
        Array of bhp slices. Dimensions: # slices x len(dt_bin_centers)    
    bin_edges : ndarray
        One-dimensional array of bin edges, time or energy
    bin_units : str, optional
        Units for labels. 'time' or 'energy'
    slice_range : ndarray
        Array of slice ranges. Dimensions: # slices x 2 (min, max)
        Either time or energy
    new_fig : bool, optional
        Option to start new figure
    show_flag : bool, optional
        Option to display
    
    Returns
    -------
    legend_text : str
        String of legend text
    '''
    if new_fig: plt.figure(figsize=(4,3))
    legend_text = []    
    
    color = iter(cm.rainbow(np.linspace(0,1,bhp_slices.shape[0]))) # Set up colors for plotting
    
    for i in range(bhp_slices.shape[0]): # Loop through slices
        c = next(color);         
        plot_bhp_slice(bhp_slices[i,:],bin_edges,bin_units,slice_range[i,:],normalized='int',c=c,clear=False,new_fig=False,title=False)
        if slice_range is not None: legend_text.append('{:04.2f} to {:04.2f}'.format(np.min(slice_range[i,:]),np.max(slice_range[i,:])))
        
    plt.legend(legend_text)
    plt.title('Slices normalized by integral')
    
    # Hack legend       
    ax = plt.gca()
    leg = ax.get_legend()
    color = iter(cm.rainbow(np.linspace(0,1,bhp_slices.shape[0]))) # Reset colors
    for i in range(bhp_slices.shape[0]): # Make legend
        c = next(color)
        leg.legendHandles[i].set_color(c)        
    
    if show_flag: plt.show()

    return legend_text
    